node {

    //Set Absolute Path to src files here
    env.PROJECT_PATH_PREFIX="src/optA-Shell-script"


    checkout scm
    withEnv(['HOME=.']) {          
                stage ('Build') {
                    sh """
                        cd "$PROJECT_PATH_PREFIX/app"  #FIX change back later to src/app
                        docker-compose build
                    """
                }
                
                stage('Upload to IEM and deploy on Device') {
                    sh '''
                    # A flag for bash scripts to exit on error
                    set -e

                    # Set environment variables
                    export IE_SKIP_CERTIFICATE=true
                    export EDGE_SKIP_TLS=1

                    echo "----- Prepare workspace ------"
                    rm -rf "$PROJECT_PATH_PREFIX/workspace"
                    mkdir "$PROJECT_PATH_PREFIX/workspace"
                    cp -RT "$PROJECT_PATH_PREFIX/app" "$PROJECT_PATH_PREFIX/workspace" #FIX change back later to src/app

                    echo "----- Set publisher configuration ------"
                    iectl config add publisher --name "iemdev" --dockerurl "http://docker:2375" --workspace "$PROJECT_PATH_PREFIX/workspace"

                    # init workspace and copy app files
                    iectl publisher workspace init

                    echo "----- IEM Login ------"
                    iectl config add iem --name 'iemdev' --url "$IEM_URL" --user "$USER_NAME" --password "$PSWD"

                    echo "----- Create new app version ------"
                    # I have used BUILD_NUMBER from Jenkins to create versions. If the apps are being deployed differentley as well you would need to get the version via "app-details" \
                    iectl publisher app-project version create \
                        -a "$APP_ID" \
                        -v "0.0.${BUILD_NUMBER}" \
                        -y "$PROJECT_PATH_PREFIX/app/docker-compose.prod.yml" \
                        -n '{"JenkinsCICD-Demo":[{"name":"JenkinsCICD-Demo","protocol":"HTTP","port":"80","headers":"","rewriteTarget":"/"}]}' \
                        -s 'JenkinsCICD-Demo' \
                        -t 'FromBoxReverseProxy' \
                        -u 'JenkinsCICD-Demo' \
                        -r '/'

# maaaany test

# Zeige die Variablen (prüft, ob sie gesetzt sind)
echo "APP_NAME=[$APP_NAME]"
echo "APP_ID=[$APP_ID]"
echo "BUILD_NUMBER=[$BUILD_NUMBER]"
echo "PROJECT_PATH_PREFIX=[$PROJECT_PATH_PREFIX]"
echo "PUBLISHER_WS=[$PUBLISHER_WS]"

# Prüfe Inhalt des Publisher-Workspaces (muss docker-compose.prod.yml enthalten)
ls -la "$PUBLISHER_WS" || ls -la "$PROJECT_PATH_PREFIX/workspace"

# Prüfe die publisher-Konfiguration und die iem-Konfiguration
iectl config list
iectl config show publisher
iectl config show iem

# Liste die Apps im Publisher-Kontext (verfügbar zum Upload / Version erstellen)
iectl publisher app-project list --verbose || iectl publisher app-project list

# Liste die Apps in der IEM (um zu prüfen, ob App bereits in IEM existiert)
iectl iem app-project list --verbose || iectl iem app-project list

# Optional: Details zur konkreten App (wenn du APP_ID oder -Name hast)
iectl iem app-project app-details --app-id "$APP_ID" || iectl iem app-project app-details --project-name "<proj>" --app-name "$APP_NAME"

# Wiederhole Upload mit verbose-Flag, damit iectl mehr Infos ausgibt
iectl --verbose publisher app-project upload catalog --appname "$APP_NAME" -v "0.0.${BUILD_NUMBER}"

# tests end



                    echo "----- Upload app version to IEM ------"
                    iectl publisher app-project upload catalog \
                        --appname $APP_NAME \
                        -v "0.0.${BUILD_NUMBER}"

                    echo "----- Deploy on edge device ------"
                    iectl iem app-project install \
                        -a "$APP_NAME" \
                       --version "0.0.${BUILD_NUMBER}" \
                        -i '{"devices":["'"$EDGE_DEVICE_ID"'"]}'                    
                    '''
                }

                stage('Cleanup Docker') {
                    sh '''
                    docker ps -a | grep docker:24-dind | awk \'{print $1}\' | xargs -r docker rm -f
                    docker system prune -af || true
                    docker images -f "dangling=true" -q | xargs --no-run-if-empty docker rmi || true
                    '''
                }
    }        
 }

