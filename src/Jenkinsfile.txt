node {
    checkout scm
    withEnv(['HOME=.']) {          
        docker.image('docker:24-dind').withRun('-p 2376:2375 --privileged -e DOCKER_TLS_CERTDIR=""') { c ->
            // Dynamic check for Dind-Daemon readiness
            // This script could be removed on stronger systems
            script {
                def dindReady = false
                echo "Waiting for Dind-Daemon..."

                for (int i = 0; i < 60; i++) {
                    try {
                        sh "docker --host tcp://localhost:2376 info > /dev/null 2>&1"
                        echo "Dind-Daemon is ready!"
                        dindReady = true
                        break 
                    } catch (Exception e) {
                        echo "Dind-Daemon is not ready yet, trying again in 1 second... (${i+1}/60)"
                        sleep 1 
                    }
                }

                if (!dindReady) {
                    error "Dind-Daemon is not ready in the expected timeframe."
                }
            }
            //Start the Docker CLI inside the Dind container
            docker.image("${env.DOCKER_IMAGE_CLI}").inside("--link ${c.id}:docker --privileged -u root") {
                stage ('Build') {
                    sh """
                        cd src/app
                        export DOCKER_HOST=tcp://docker:2375
                        docker-compose build
                        docker images
                        cd ..
                    """
                }
                // Push the image to the registry
                stage ('Upload') {
                     sh """
                        export DOCKER_HOST=tcp://docker:2375
                        cp -RT src/app /app/src/workspace
                        cd /app/src/workspace
                        ie-app-publisher-linux de c -u http://docker:2375
                        export IE_SKIP_CERTIFICATE=true
                        ie-app-publisher-linux em li -u "$IEM_URL" -e $USER_NAME -p $PSWD
                        ie-app-publisher-linux em app cuv -a $APP_ID -v 0.0.$BUILD_NUMBER -y ./docker-compose.prod.yml -n '{"hello-edge":[{"name":"hello-edge","protocol":"HTTP","port":"80","headers":"","rewriteTarget":"/"}]}' -s 'hello-edge' -t 'FromBoxReverseProxy' -u "hello-edge" -r "/"
                        ie-app-publisher-linux em app uuv -a $APP_ID -v 0.0.$BUILD_NUMBER
                     """
                }
                /* Deploy the image to the edge device
                stage('Deploy to Device') {
                    script {
                        sh '''
                            set -e

                            # Environmentvariablen wie gehabt
                            echo "APP_ID=$APP_ID"
                            echo "EDGE_DEVICE_ID=$EDGE_DEVICE_ID"
                            echo "USER_NAME=$USER_NAME"
                            echo "PSWD=<hidden>"
                            echo "IEM_URL=$IEM_URL"

                            VERSION="0.0.$BUILD_NUMBER"

                            # Token holen
                            IEM_TOKEN=$(curl -s -X POST \
                                -H "Content-Type: application/json" \
                                -d '{"username":"'"$USER_NAME"'","password":"'"$PSWD"'"}' \
                                --insecure \
                                "$IEM_URL/portal/api/v1/login/direct" | jq -r '.data.access_token')

                            if [ -z "$IEM_TOKEN" ] || [ "$IEM_TOKEN" == "null" ]; then
                                echo "ERROR: Failed to get IEM access_token!"
                                exit 2
                            fi

                            DEPLOY_OUTPUT="deploy_curl_response.txt"



                                        # Warteschleife 1-3 Minuten (maximal 18*10s = 3 Minuten)
                                        export IE_SKIP_CERTIFICATE=true
                                        ie-app-publisher-linux em li -u "$IEM_URL" -e "$USER_NAME" -p "$PSWD"

                                        echo "Warte, bis neue App-Version im Status 'PUBLISHED' oder 'RELEASED' ist ..."
                                        for i in {1..18}; do
                                            RESPONSE=$(ie-app-publisher-linux em app detail -a "$APP_ID" 2>&1)
                                            if echo "$RESPONSE" | grep -q 'Application detail not found'; then
                                                echo "IEM noch nicht synchron, retry in 10s ..."
                                                sleep 10
                                                continue
                                            fi
                                            STATUS=$(echo "$RESPONSE" | jq -r '.versions[] | select(.versionNumber=="'$VERSION'") | .status')
                                            echo "Version $VERSION Status: $STATUS"
                                            if [ "$STATUS" = "PUBLISHED" ] || [ "$STATUS" = "RELEASED" ]; then
                                                echo "Version $VERSION ist $STATUS! Deployment wird gestartet."
                                                break
                                            fi
                                            sleep 10
                                        done



                            curl -i -X POST \
                                -H "Authorization: Bearer $IEM_TOKEN" \
                                -H "Content-Type:multipart/form-data" \
                                -F "infoMap={\\\"devices\\\":[\\\"$EDGE_DEVICE_ID\\\"]}" \
                                --insecure \
                                "$IEM_URL/portal/api/v1/batches?appid=$APP_ID&operation=installApplication" \
                                > "$DEPLOY_OUTPUT" 2>&1

                            STATUS=$(grep HTTP "$DEPLOY_OUTPUT" | tail -1 | awk '{print $2}')
                            echo "Deployment HTTP-Status: $STATUS"
                            cat "$DEPLOY_OUTPUT"

                            if [ "$STATUS" != "200" ] && [ "$STATUS" != "201" ]; then
                                echo "ERROR: Deployment failed, see above."
                                exit 1
                            fi
                        '''
                    }
                }*/
                stage('Deploy to Device') {
                    script {
                        // Die Version der App, die deployed werden soll
                        def appVersion = "0.0.${env.BUILD_NUMBER}"

                        // 1. Authentifizierung am IEM (OAuth2)
                        def iemAccessToken
                        withCredentials([string(credentialsId: 'IEM_CLIENT_ID', variable: 'IEM_CLIENT_ID'),
                                         string(credentialsId: 'IEM_CLIENT_SECRET', variable: 'IEM_CLIENT_SECRET')]) {
                            echo "Authenticating with IEM using OAuth2..."
                            def tokenResponse = sh(returnStdout: true, script: """
                                curl -s -X POST "${env.IEM_URL}/api/oauth2/v1/token" \\
                                     -H "Content-Type: application/x-www-form-urlencoded" \\
                                     -d "grant_type=client_credentials&client_id=${IEM_CLIENT_ID}&client_secret=${IEM_CLIENT_SECRET}" \\
                                     --insecure
                            """)
                            iemAccessToken = new groovy.json.JsonSlurper().parseText(tokenResponse).access_token
                            if (!iemAccessToken) {
                                error "ERROR: Failed to get IEM OAuth2 access_token!"
                            }
                            echo "IEM OAuth2 Authentication successful."
                        }

                        // 2. App-ID ermitteln (falls nicht schon als env.APP_ID vorhanden)
                        // Da du bereits $APP_ID verwendest, nehmen wir an, diese ist korrekt.
                        // Falls du die ID aus dem Namen und der Version dynamisch abfragen müsstest,
                        // wäre hier der GET /api/applications/v1/applications?name=... Aufruf.
                        def appId = env.APP_ID
                        echo "Using Application ID: ${appId} for deployment."

                        // 3. Deployment auf das spezifische Gerät auslösen
                        echo "Triggering deployment of App ${appId} (Version ${appVersion}) to Device ${env.EDGE_DEVICE_ID}..."
                        def deploymentOrderResponse = sh(returnStdout: true, script: """
                            curl -s -X POST "${env.IEM_URL}/api/deployments/v1/deploymentOrders" \\
                                 -H "Content-Type: application/json" \\
                                 -H "Authorization: Bearer ${iemAccessToken}" \\
                                 -d '{
                                     "applicationId": "${appId}",
                                     "version": "${appVersion}",
                                     "targetDevices": [
                                         "${env.EDGE_DEVICE_ID}"
                                     ]
                                 }' \\
                                 --insecure
                        """)

                        def deploymentOrderId = new groovy.json.JsonSlurper().parseText(deploymentOrderResponse).id
                        if (!deploymentOrderId) {
                            error "ERROR: Failed to create deployment order. Response: ${deploymentOrderResponse}"
                        }
                        echo "Deployment order created with ID: ${deploymentOrderId}"

                        // 4. Überwachung des Deployment-Status
                        def deploymentStatus = ""
                        def maxRetries = 60 // Max 60 Checks, z.B. 60 * 10 Sekunden = 10 Minuten
                        def retryCount = 0
                        def checkIntervalSeconds = 10

                        echo "Monitoring deployment order ${deploymentOrderId}..."

                        while (deploymentStatus != "COMPLETED" && deploymentStatus != "FAILED" && retryCount < maxRetries) {
                            sleep checkIntervalSeconds
                            retryCount++

                            def statusResponse = sh(returnStdout: true, script: """
                                curl -s -X GET "${env.IEM_URL}/api/deployments/v1/deploymentOrders/${deploymentOrderId}/status" \\
                                     -H "Authorization: Bearer ${iemAccessToken}" \\
                                     -H "Accept: application/json" \\
                                     --insecure
                            """)
                            
                            def parsedStatusResponse = new groovy.json.JsonSlurper().parseText(statusResponse)
                            deploymentStatus = parsedStatusResponse.status

                            echo "Deployment status: ${deploymentStatus} (Attempt ${retryCount}/${maxRetries})"
                            
                            if (parsedStatusResponse.errors && !parsedStatusResponse.errors.isEmpty()) {
                                echo "Deployment errors detected: ${parsedStatusResponse.errors}"
                                // Optional: Hier könntest du detailliertere Fehlerbehandlung einfügen
                            }
                        }

                        if (deploymentStatus == "COMPLETED") {
                            echo "Deployment successfully completed on device ${env.EDGE_DEVICE_ID}!"
                        } else if (deploymentStatus == "FAILED") {
                            error "Deployment failed on device ${env.EDGE_DEVICE_ID}. Check IEM for details."
                        } else {
                            error "Deployment status could not be determined or timed out after ${maxRetries} attempts."
                        }
                    }
                }
                stage('Cleanup Docker') {
                    sh '''
                    docker system prune -af || true
                    docker images -f "dangling=true" -q | xargs --no-run-if-empty docker rmi || true
                    '''
                }
            }        
        }
    }
}